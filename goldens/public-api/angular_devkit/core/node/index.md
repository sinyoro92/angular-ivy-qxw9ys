## API Report File for "@angular-devkit/core_node"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { ErrorObject } from 'ajv';
import { Format } from 'ajv';
import { Observable } from 'rxjs';
import { Observer } from 'rxjs';
import { Operator } from 'rxjs';
import { PartialObserver } from 'rxjs';
import { Stats as Stats_2 } from 'fs';
import { Subject } from 'rxjs';
import { SubscribableOrPromise } from 'rxjs';
import { Subscription } from 'rxjs';
import { ValidateFunction } from 'ajv';

// @public (undocumented)
function addUndefinedDefaults(value: JsonValue, _pointer: JsonPointer, schema?: JsonSchema): JsonValue;

// @public
class AliasHost<StatsT extends object = {}> extends ResolverHost<StatsT> {
    // (undocumented)
    get aliases(): Map<Path, Path>;
    // (undocumented)
    protected _aliases: Map<Path, Path>;
    // (undocumented)
    protected _resolve(path: Path): Path;
}

// @public (undocumented)
function buildJsonPointer(fragments: string[]): JsonPointer;

// @public (undocumented)
class ChannelAlreadyExistException extends BaseException {
    constructor(name: string);
}

// @public
class CordHost extends SimpleMemoryHost {
    constructor(_back: ReadonlyHost);
    // (undocumented)
    protected _back: ReadonlyHost;
    // (undocumented)
    get backend(): ReadonlyHost;
    // (undocumented)
    get capabilities(): HostCapabilities;
    clone(): CordHost;
    commit(host: Host, force?: boolean): Observable<void>;
    create(path: Path, content: FileBuffer): Observable<void>;
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    protected _filesToCreate: Set<Path>;
    // (undocumented)
    protected _filesToDelete: Set<Path>;
    // (undocumented)
    protected _filesToOverwrite: Set<Path>;
    // (undocumented)
    protected _filesToRename: Map<Path, Path>;
    // (undocumented)
    protected _filesToRenameRevert: Map<Path, Path>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    overwrite(path: Path, content: FileBuffer): Observable<void>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    records(): CordHostRecord[];
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    stat(path: Path): Observable<Stats | null> | null;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): null;
    // (undocumented)
    willCreate(path: Path): boolean;
    // (undocumented)
    willDelete(path: Path): boolean;
    // (undocumented)
    willOverwrite(path: Path): boolean;
    // (undocumented)
    willRename(path: Path): boolean;
    // (undocumented)
    willRenameTo(path: Path, to: Path): boolean;
    // (undocumented)
    write(path: Path, content: FileBuffer): Observable<void>;
}

// @public (undocumented)
interface CordHostCreate {
    // (undocumented)
    content: FileBuffer;
    // (undocumented)
    kind: 'create';
    // (undocumented)
    path: Path;
}

// @public (undocumented)
interface CordHostDelete {
    // (undocumented)
    kind: 'delete';
    // (undocumented)
    path: Path;
}

// @public (undocumented)
interface CordHostOverwrite {
    // (undocumented)
    content: FileBuffer;
    // (undocumented)
    kind: 'overwrite';
    // (undocumented)
    path: Path;
}

// @public (undocumented)
type CordHostRecord = CordHostCreate | CordHostOverwrite | CordHostRename | CordHostDelete;

// @public (undocumented)
interface CordHostRename {
    // (undocumented)
    from: Path;
    // (undocumented)
    kind: 'rename';
    // (undocumented)
    to: Path;
}

// @public (undocumented)
class CoreSchemaRegistry implements SchemaRegistry {
    constructor(formats?: SchemaFormat[]);
    // (undocumented)
    addFormat(format: SchemaFormat): void;
    addPostTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    addPreTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    // (undocumented)
    addSmartDefaultProvider<T>(source: string, provider: SmartDefaultProvider<T>): void;
    compile(schema: JsonSchema): Observable<SchemaValidator>;
    // @deprecated
    flatten(schema: JsonObject): Observable<JsonObject>;
    // (undocumented)
    registerUriHandler(handler: UriHandler): void;
    // (undocumented)
    protected _resolver(ref: string, validate?: ValidateFunction): {
        context?: ValidateFunction;
        schema?: JsonObject;
    };
    // (undocumented)
    usePromptProvider(provider: PromptProvider): void;
    // (undocumented)
    useXDeprecatedProvider(onUsage: (message: string) => void): void;
}

// @public
export function createConsoleLogger(verbose?: boolean, stdout?: ProcessOutput, stderr?: ProcessOutput, colors?: Partial<Record<logging.LogLevel, (s: string) => string>>): logging.Logger;

// @public
function createDispatcher<A extends JsonValue, I extends JsonValue, O extends JsonValue>(options?: Partial<Readwrite<JobDescription>>): JobDispatcher<A, I, O>;

// @public
function createJobFactory<A extends JsonValue, I extends JsonValue, O extends JsonValue>(loader: () => Promise<JobHandler<A, I, O>>, options?: Partial<JobDescription>): JobHandler<A, I, O>;

// @public
function createJobHandler<A extends JsonValue, I extends JsonValue, O extends JsonValue>(fn: SimpleJobHandlerFn<A, I, O>, options?: Partial<JobDescription>): JobHandler<A, I, O>;

// @public
function createLoggerJob<A extends JsonValue, I extends JsonValue, O extends JsonValue>(job: JobHandler<A, I, O>, logger: LoggerApi): JobHandler<A, I, O>;

// @public (undocumented)
function createSyncHost<StatsT extends object = {}>(handler: SyncHostHandler<StatsT>): Host<StatsT>;

// @public (undocumented)
class Empty implements ReadonlyHost {
    // (undocumented)
    readonly capabilities: HostCapabilities;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    stat(path: Path): Observable<Stats<{}> | null>;
}

declare namespace experimental {
    export {
        NodeModuleJobRegistry
    }
}
export { experimental }

// @public
class FallbackRegistry<MinimumArgumentValueT extends JsonValue = JsonValue, MinimumInputValueT extends JsonValue = JsonValue, MinimumOutputValueT extends JsonValue = JsonValue> implements Registry<MinimumArgumentValueT, MinimumInputValueT, MinimumOutputValueT> {
    constructor(_fallbacks?: Registry<MinimumArgumentValueT, MinimumInputValueT, MinimumOutputValueT>[]);
    // (undocumented)
    addFallback(registry: Registry): void;
    // (undocumented)
    protected _fallbacks: Registry<MinimumArgumentValueT, MinimumInputValueT, MinimumOutputValueT>[];
    // (undocumented)
    get<A extends MinimumArgumentValueT = MinimumArgumentValueT, I extends MinimumInputValueT = MinimumInputValueT, O extends MinimumOutputValueT = MinimumOutputValueT>(name: JobName): Observable<JobHandler<A, I, O> | null>;
}

// @public (undocumented)
type FileBuffer = ArrayBuffer;

// @public (undocumented)
const fileBuffer: TemplateTag<FileBuffer>;

// @public (undocumented)
type FileBufferLike = ArrayBufferLike;

// @public (undocumented)
function fileBufferToString(fileBuffer: FileBuffer): string;

// @public (undocumented)
function getTypesOfSchema(schema: JsonSchema): Set<string>;

// @public (undocumented)
interface Host<StatsT extends object = {}> extends ReadonlyHost<StatsT> {
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    write(path: Path, content: FileBufferLike): Observable<void>;
}

// @public (undocumented)
interface HostCapabilities {
    // (undocumented)
    synchronous: boolean;
}

// @public (undocumented)
interface HostWatchEvent {
    // (undocumented)
    readonly path: Path;
    // (undocumented)
    readonly time: Date;
    // (undocumented)
    readonly type: HostWatchEventType;
}

// @public (undocumented)
const enum HostWatchEventType {
    // (undocumented)
    Changed = 0,
    // (undocumented)
    Created = 1,
    // (undocumented)
    Deleted = 2,
    // (undocumented)
    Renamed = 3
}

// @public (undocumented)
interface HostWatchOptions {
    // (undocumented)
    readonly persistent?: boolean;
    // (undocumented)
    readonly recursive?: boolean;
}

// @public (undocumented)
class IndentLogger extends Logger {
    constructor(name: string, parent?: Logger | null, indentation?: string);
}

// @public (undocumented)
function isJobHandler<A extends JsonValue, I extends JsonValue, O extends JsonValue>(value: unknown): value is JobHandler<A, I, O>;

// @public (undocumented)
function isJsonSchema(value: unknown): value is JsonSchema;

// @public
interface Job<ArgumentT extends JsonValue = JsonValue, InputT extends JsonValue = JsonValue, OutputT extends JsonValue = JsonValue> {
    readonly argument: ArgumentT;
    readonly description: Observable<JobDescription>;
    getChannel<T extends JsonValue>(name: string, schema?: schema.JsonSchema): Observable<T>;
    readonly inboundBus: Observer<JobInboundMessage<InputT>>;
    readonly input: Observer<InputT>;
    readonly outboundBus: Observable<JobOutboundMessage<OutputT>>;
    readonly output: Observable<OutputT>;
    ping(): Observable<never>;
    readonly state: JobState;
    stop(): void;
}

// @public (undocumented)
class JobArgumentSchemaValidationError extends schema.SchemaValidationException {
    constructor(errors?: schema.SchemaValidatorError[]);
}

// @public
interface JobDescription extends JsonObject {
    // (undocumented)
    readonly argument: DeepReadonly<schema.JsonSchema>;
    // (undocumented)
    readonly input: DeepReadonly<schema.JsonSchema>;
    // (undocumented)
    readonly name: JobName;
    // (undocumented)
    readonly output: DeepReadonly<schema.JsonSchema>;
}

// @public
interface JobDispatcher<A extends JsonValue, I extends JsonValue, O extends JsonValue> extends JobHandler<A, I, O> {
    addConditionalJob(predicate: (args: A) => boolean, name: string): void;
    setDefaultJob(name: JobName | null | JobHandler<JsonValue, JsonValue, JsonValue>): void;
}

// @public (undocumented)
class JobDoesNotExistException extends BaseException {
    constructor(name: JobName);
}

// @public
interface JobHandler<ArgT extends JsonValue, InputT extends JsonValue, OutputT extends JsonValue> {
    // (undocumented)
    (argument: ArgT, context: JobHandlerContext<ArgT, InputT, OutputT>): Observable<JobOutboundMessage<OutputT>>;
    // (undocumented)
    jobDescription: Partial<JobDescription>;
}

// @public
interface JobHandlerContext<MinimumArgumentValueT extends JsonValue = JsonValue, MinimumInputValueT extends JsonValue = JsonValue, MinimumOutputValueT extends JsonValue = JsonValue> {
    // (undocumented)
    readonly dependencies: Job<JsonValue, JsonValue, JsonValue>[];
    // (undocumented)
    readonly description: JobDescription;
    // (undocumented)
    readonly inboundBus: Observable<JobInboundMessage<MinimumInputValueT>>;
    // (undocumented)
    readonly scheduler: Scheduler<JsonValue, JsonValue, JsonValue>;
}

// @public (undocumented)
type JobInboundMessage<InputT extends JsonValue> = JobInboundMessagePing | JobInboundMessageStop | JobInboundMessageInput<InputT>;

// @public
interface JobInboundMessageBase extends JsonObject {
    readonly kind: JobInboundMessageKind;
}

// @public
interface JobInboundMessageInput<InputT extends JsonValue> extends JobInboundMessageBase {
    // (undocumented)
    readonly kind: JobInboundMessageKind.Input;
    readonly value: InputT;
}

// @public
enum JobInboundMessageKind {
    // (undocumented)
    Input = "in",
    // (undocumented)
    Ping = "ip",
    // (undocumented)
    Stop = "is"
}

// @public
interface JobInboundMessagePing extends JobInboundMessageBase {
    readonly id: number;
    // (undocumented)
    readonly kind: JobInboundMessageKind.Ping;
}

// @public (undocumented)
class JobInboundMessageSchemaValidationError extends schema.SchemaValidationException {
    constructor(errors?: schema.SchemaValidatorError[]);
}

// @public
interface JobInboundMessageStop extends JobInboundMessageBase {
    // (undocumented)
    readonly kind: JobInboundMessageKind.Stop;
}

// @public
type JobName = string;

// @public (undocumented)
class JobNameAlreadyRegisteredException extends BaseException {
    constructor(name: JobName);
}

// @public
type JobOutboundMessage<OutputT extends JsonValue> = JobOutboundMessageOnReady | JobOutboundMessageStart | JobOutboundMessageOutput<OutputT> | JobOutboundMessageChannelCreate | JobOutboundMessageChannelMessage | JobOutboundMessageChannelError | JobOutboundMessageChannelComplete | JobOutboundMessageEnd | JobOutboundMessagePong;

// @public
interface JobOutboundMessageBase {
    readonly description: JobDescription;
    readonly kind: JobOutboundMessageKind;
}

// @public
interface JobOutboundMessageChannelBase extends JobOutboundMessageBase {
    readonly name: string;
}

// @public
interface JobOutboundMessageChannelComplete extends JobOutboundMessageChannelBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.ChannelComplete;
}

// @public
interface JobOutboundMessageChannelCreate extends JobOutboundMessageChannelBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.ChannelCreate;
}

// @public
interface JobOutboundMessageChannelError extends JobOutboundMessageChannelBase {
    readonly error: JsonValue;
    // (undocumented)
    readonly kind: JobOutboundMessageKind.ChannelError;
}

// @public
interface JobOutboundMessageChannelMessage extends JobOutboundMessageChannelBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.ChannelMessage;
    readonly message: JsonValue;
}

// @public
interface JobOutboundMessageEnd extends JobOutboundMessageBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.End;
}

// @public
enum JobOutboundMessageKind {
    // (undocumented)
    ChannelComplete = "cc",
    // (undocumented)
    ChannelCreate = "cn",
    // (undocumented)
    ChannelError = "ce",
    // (undocumented)
    ChannelMessage = "cm",
    // (undocumented)
    End = "e",
    // (undocumented)
    OnReady = "c",
    // (undocumented)
    Output = "o",
    // (undocumented)
    Pong = "p",
    // (undocumented)
    Start = "s"
}

// @public
interface JobOutboundMessageOnReady extends JobOutboundMessageBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.OnReady;
}

// @public
interface JobOutboundMessageOutput<OutputT extends JsonValue> extends JobOutboundMessageBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.Output;
    readonly value: OutputT;
}

// @public
interface JobOutboundMessagePong extends JobOutboundMessageBase {
    readonly id: number;
    // (undocumented)
    readonly kind: JobOutboundMessageKind.Pong;
}

// @public
interface JobOutboundMessageStart extends JobOutboundMessageBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.Start;
}

// @public (undocumented)
class JobOutputSchemaValidationError extends schema.SchemaValidationException {
    constructor(errors?: schema.SchemaValidatorError[]);
}

declare namespace jobs {
    export {
        isJobHandler,
        JobName,
        JobHandler,
        JobHandlerContext,
        JobDescription,
        JobInboundMessageKind,
        JobInboundMessageBase,
        JobInboundMessagePing,
        JobInboundMessageStop,
        JobInboundMessageInput,
        JobInboundMessage,
        JobOutboundMessageKind,
        JobOutboundMessageBase,
        JobOutboundMessageOnReady,
        JobOutboundMessageStart,
        JobOutboundMessageOutput,
        JobOutboundMessageChannelBase,
        JobOutboundMessageChannelMessage,
        JobOutboundMessageChannelError,
        JobOutboundMessageChannelCreate,
        JobOutboundMessageChannelComplete,
        JobOutboundMessageEnd,
        JobOutboundMessagePong,
        JobOutboundMessage,
        JobState,
        Job,
        ScheduleJobOptions,
        Registry,
        Scheduler,
        createJobHandler,
        createJobFactory,
        createLoggerJob,
        ChannelAlreadyExistException,
        SimpleJobHandlerContext,
        SimpleJobHandlerFn,
        JobNameAlreadyRegisteredException,
        JobDoesNotExistException,
        createDispatcher,
        JobDispatcher,
        FallbackRegistry,
        RegisterJobOptions,
        SimpleJobRegistry,
        JobArgumentSchemaValidationError,
        JobInboundMessageSchemaValidationError,
        JobOutputSchemaValidationError,
        SimpleScheduler,
        strategy
    }
}

// @public
enum JobState {
    Ended = "ended",
    Errored = "errored",
    Queued = "queued",
    Ready = "ready",
    Started = "started"
}

// @public (undocumented)
function joinJsonPointer(root: JsonPointer, ...others: string[]): JsonPointer;

// @public (undocumented)
type JsonPointer = string & {
    __PRIVATE_DEVKIT_JSON_POINTER: void;
};

// @public
type JsonSchema = JsonObject | boolean;

// @public (undocumented)
interface JsonSchemaVisitor {
    // (undocumented)
    (current: JsonObject | JsonArray, pointer: JsonPointer, parentSchema?: JsonObject | JsonArray, index?: string): void;
}

// @public (undocumented)
interface JsonVisitor {
    // (undocumented)
    (value: JsonValue, pointer: JsonPointer, schema?: JsonObject, root?: JsonObject | JsonArray): Observable<JsonValue> | JsonValue;
}

// @public (undocumented)
class LevelCapLogger extends LevelTransformLogger {
    constructor(name: string, parent: Logger | null, levelCap: LogLevel);
    // (undocumented)
    readonly levelCap: LogLevel;
    // (undocumented)
    static levelMap: {
        [cap: string]: {
            [level: string]: string;
        };
    };
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly parent: Logger | null;
}

// @public (undocumented)
class LevelTransformLogger extends Logger {
    constructor(name: string, parent: Logger | null, levelTransform: (level: LogLevel) => LogLevel);
    // (undocumented)
    createChild(name: string): Logger;
    // (undocumented)
    readonly levelTransform: (level: LogLevel) => LogLevel;
    // (undocumented)
    log(level: LogLevel, message: string, metadata?: JsonObject): void;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly parent: Logger | null;
}

// @public (undocumented)
interface LogEntry extends LoggerMetadata {
    // (undocumented)
    level: LogLevel;
    // (undocumented)
    message: string;
    // (undocumented)
    timestamp: number;
}

// @public (undocumented)
class Logger extends Observable<LogEntry> implements LoggerApi {
    constructor(name: string, parent?: Logger | null);
    // (undocumented)
    asApi(): LoggerApi;
    // (undocumented)
    complete(): void;
    // (undocumented)
    createChild(name: string): Logger;
    // (undocumented)
    debug(message: string, metadata?: JsonObject): void;
    // (undocumented)
    error(message: string, metadata?: JsonObject): void;
    // (undocumented)
    fatal(message: string, metadata?: JsonObject): void;
    // (undocumented)
    forEach(next: (value: LogEntry) => void, PromiseCtor?: typeof Promise): Promise<void>;
    // (undocumented)
    info(message: string, metadata?: JsonObject): void;
    // (undocumented)
    lift<R>(operator: Operator<LogEntry, R>): Observable<R>;
    // (undocumented)
    log(level: LogLevel, message: string, metadata?: JsonObject): void;
    // (undocumented)
    protected _metadata: LoggerMetadata;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    next(entry: LogEntry): void;
    // (undocumented)
    protected get _observable(): Observable<LogEntry>;
    protected set _observable(v: Observable<LogEntry>);
    // (undocumented)
    readonly parent: Logger | null;
    // (undocumented)
    protected readonly _subject: Subject<LogEntry>;
    // (undocumented)
    subscribe(): Subscription;
    // (undocumented)
    subscribe(observer: PartialObserver<LogEntry>): Subscription;
    // (undocumented)
    subscribe(next?: (value: LogEntry) => void, error?: (error: Error) => void, complete?: () => void): Subscription;
    // (undocumented)
    toString(): string;
    // (undocumented)
    warn(message: string, metadata?: JsonObject): void;
}

// @public (undocumented)
interface LoggerApi {
    // (undocumented)
    createChild(name: string): Logger;
    // (undocumented)
    debug(message: string, metadata?: JsonObject): void;
    // (undocumented)
    error(message: string, metadata?: JsonObject): void;
    // (undocumented)
    fatal(message: string, metadata?: JsonObject): void;
    // (undocumented)
    info(message: string, metadata?: JsonObject): void;
    // (undocumented)
    log(level: LogLevel, message: string, metadata?: JsonObject): void;
    // (undocumented)
    warn(message: string, metadata?: JsonObject): void;
}

// @public (undocumented)
interface LoggerMetadata extends JsonObject {
    // (undocumented)
    name: string;
    // (undocumented)
    path: string[];
}

// @public (undocumented)
type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'fatal';

// @public
function mergeSchemas(...schemas: (JsonSchema | undefined)[]): JsonSchema;

// @public
export class NodeJsAsyncHost implements virtualFs.Host<Stats_2> {
    // (undocumented)
    get capabilities(): virtualFs.HostCapabilities;
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<virtualFs.FileBuffer>;
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    stat(path: Path): Observable<virtualFs.Stats<Stats_2>>;
    // (undocumented)
    watch(path: Path, _options?: virtualFs.HostWatchOptions): Observable<virtualFs.HostWatchEvent> | null;
    // (undocumented)
    write(path: Path, content: virtualFs.FileBuffer): Observable<void>;
}

// @public
export class NodeJsSyncHost implements virtualFs.Host<Stats_2> {
    // (undocumented)
    get capabilities(): virtualFs.HostCapabilities;
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<virtualFs.FileBuffer>;
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    stat(path: Path): Observable<virtualFs.Stats<Stats_2>>;
    // (undocumented)
    watch(path: Path, _options?: virtualFs.HostWatchOptions): Observable<virtualFs.HostWatchEvent> | null;
    // (undocumented)
    write(path: Path, content: virtualFs.FileBuffer): Observable<void>;
}

// @public (undocumented)
class NodeModuleJobRegistry<MinimumArgumentValueT extends JsonValue = JsonValue, MinimumInputValueT extends JsonValue = JsonValue, MinimumOutputValueT extends JsonValue = JsonValue> implements experimental_2.jobs.Registry<MinimumArgumentValueT, MinimumInputValueT, MinimumOutputValueT> {
    get<A extends MinimumArgumentValueT, I extends MinimumInputValueT, O extends MinimumOutputValueT>(name: experimental_2.jobs.JobName): Observable<experimental_2.jobs.JobHandler<A, I, O> | null>;
    // (undocumented)
    protected _resolve(name: string): string | null;
}

// @public (undocumented)
class NullLogger extends Logger {
    constructor(parent?: Logger | null);
    // (undocumented)
    asApi(): LoggerApi;
}

// @public (undocumented)
function parseJsonPointer(pointer: JsonPointer): string[];

// @public (undocumented)
class PatternMatchingHost<StatsT extends object = {}> extends ResolverHost<StatsT> {
    // (undocumented)
    addPattern(pattern: string | string[], replacementFn: ReplacementFunction): void;
    // (undocumented)
    protected _patterns: Map<RegExp, ReplacementFunction>;
    // (undocumented)
    protected _resolve(path: Path): Path;
}

// @public (undocumented)
export interface ProcessOutput {
    // (undocumented)
    write(buffer: string | Buffer): boolean;
}

// @public (undocumented)
interface PromptDefinition {
    // (undocumented)
    default?: string | string[] | number | boolean | null;
    // (undocumented)
    id: string;
    // (undocumented)
    items?: Array<string | {
        value: JsonValue;
        label: string;
    }>;
    // (undocumented)
    message: string;
    // (undocumented)
    multiselect?: boolean;
    // (undocumented)
    propertyTypes: Set<string>;
    // (undocumented)
    raw?: string | JsonObject;
    // (undocumented)
    type: string;
    // (undocumented)
    validator?: (value: JsonValue) => boolean | string | Promise<boolean | string>;
}

// @public (undocumented)
type PromptProvider = (definitions: Array<PromptDefinition>) => SubscribableOrPromise<{
    [id: string]: JsonValue;
}>;

// @public (undocumented)
interface ReadonlyHost<StatsT extends object = {}> {
    // (undocumented)
    readonly capabilities: HostCapabilities;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    stat(path: Path): Observable<Stats<StatsT> | null> | null;
}

// @public (undocumented)
interface ReferenceResolver<ContextT> {
    // (undocumented)
    (ref: string, context?: ContextT): {
        context?: ContextT;
        schema?: JsonObject;
    };
}

// @public
interface RegisterJobOptions extends Partial<JobDescription> {
}

// @public (undocumented)
interface Registry<MinimumArgumentValueT extends JsonValue = JsonValue, MinimumInputValueT extends JsonValue = JsonValue, MinimumOutputValueT extends JsonValue = JsonValue> {
    get<A extends MinimumArgumentValueT, I extends MinimumInputValueT, O extends MinimumOutputValueT>(name: JobName): Observable<JobHandler<A, I, O> | null>;
}

// @public (undocumented)
type ReplacementFunction = (path: Path) => Path;

// @public
abstract class ResolverHost<T extends object> implements Host<T> {
    constructor(_delegate: Host<T>);
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    protected _delegate: Host<T>;
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    protected abstract _resolve(path: Path): Path;
    // (undocumented)
    stat(path: Path): Observable<Stats<T> | null> | null;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    write(path: Path, content: FileBuffer): Observable<void>;
}

// @public
class SafeReadonlyHost<StatsT extends object = {}> implements ReadonlyHost<StatsT> {
    constructor(_delegate: ReadonlyHost<StatsT>);
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    stat(path: Path): Observable<Stats<StatsT> | null> | null;
}

// @public
interface ScheduleJobOptions {
    dependencies?: Job | Job[];
}

// @public
interface Scheduler<MinimumArgumentValueT extends JsonValue = JsonValue, MinimumInputValueT extends JsonValue = JsonValue, MinimumOutputValueT extends JsonValue = JsonValue> {
    getDescription(name: JobName): Observable<JobDescription | null>;
    has(name: JobName): Observable<boolean>;
    pause(): () => void;
    schedule<A extends MinimumArgumentValueT, I extends MinimumInputValueT, O extends MinimumOutputValueT>(name: JobName, argument: A, options?: ScheduleJobOptions): Job<A, I, O>;
}

// @public (undocumented)
interface SchemaFormat {
    // (undocumented)
    formatter: SchemaFormatter;
    // (undocumented)
    name: string;
}

// @public (undocumented)
type SchemaFormatter = Format;

// @public (undocumented)
interface SchemaKeywordValidator {
    // (undocumented)
    (data: JsonValue, schema: JsonValue, parent: JsonObject | JsonArray | undefined, parentProperty: string | number | undefined, pointer: JsonPointer, rootData: JsonValue): boolean | Observable<boolean>;
}

// @public (undocumented)
interface SchemaRegistry {
    // (undocumented)
    addFormat(format: SchemaFormat): void;
    addPostTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    addPreTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    // (undocumented)
    addSmartDefaultProvider<T>(source: string, provider: SmartDefaultProvider<T>): void;
    // (undocumented)
    compile(schema: Object): Observable<SchemaValidator>;
    // @deprecated (undocumented)
    flatten(schema: JsonObject | string): Observable<JsonObject>;
    // (undocumented)
    usePromptProvider(provider: PromptProvider): void;
    // (undocumented)
    useXDeprecatedProvider(onUsage: (message: string) => void): void;
}

// @public (undocumented)
class SchemaValidationException extends BaseException {
    constructor(errors?: SchemaValidatorError[], baseMessage?: string);
    // (undocumented)
    static createMessages(errors?: SchemaValidatorError[]): string[];
    // (undocumented)
    readonly errors: SchemaValidatorError[];
}

// @public (undocumented)
interface SchemaValidator {
    // (undocumented)
    (data: JsonValue, options?: SchemaValidatorOptions): Observable<SchemaValidatorResult>;
}

// @public (undocumented)
type SchemaValidatorError = Partial<ErrorObject>;

// @public (undocumented)
interface SchemaValidatorOptions {
    // (undocumented)
    applyPostTransforms?: boolean;
    // (undocumented)
    applyPreTransforms?: boolean;
    // (undocumented)
    withPrompts?: boolean;
}

// @public (undocumented)
interface SchemaValidatorResult {
    // (undocumented)
    data: JsonValue;
    // (undocumented)
    errors?: SchemaValidatorError[];
    // (undocumented)
    success: boolean;
}

// @public (undocumented)
class ScopedHost<T extends object> extends ResolverHost<T> {
    constructor(delegate: Host<T>, _root?: Path);
    // (undocumented)
    protected _resolve(path: Path): Path;
    // (undocumented)
    protected _root: Path;
}

// @public
interface SimpleJobHandlerContext<A extends JsonValue, I extends JsonValue, O extends JsonValue> extends JobHandlerContext<A, I, O> {
    // (undocumented)
    createChannel: (name: string) => Observer<JsonValue>;
    // (undocumented)
    input: Observable<I>;
}

// @public
type SimpleJobHandlerFn<A extends JsonValue, I extends JsonValue, O extends JsonValue> = (input: A, context: SimpleJobHandlerContext<A, I, O>) => O | Promise<O> | Observable<O>;

// @public
class SimpleJobRegistry<MinimumArgumentValueT extends JsonValue = JsonValue, MinimumInputValueT extends JsonValue = JsonValue, MinimumOutputValueT extends JsonValue = JsonValue> implements Registry<MinimumArgumentValueT, MinimumInputValueT, MinimumOutputValueT> {
    // (undocumented)
    get<A extends MinimumArgumentValueT = MinimumArgumentValueT, I extends MinimumInputValueT = MinimumInputValueT, O extends MinimumOutputValueT = MinimumOutputValueT>(name: JobName): Observable<JobHandler<A, I, O> | null>;
    getJobNames(): JobName[];
    register<A extends MinimumArgumentValueT, I extends MinimumInputValueT, O extends MinimumOutputValueT>(name: JobName, handler: JobHandler<A, I, O>, options?: RegisterJobOptions): void;
    register<ArgumentT extends JsonValue, InputT extends JsonValue, OutputT extends JsonValue>(handler: JobHandler<ArgumentT, InputT, OutputT>, options?: RegisterJobOptions & {
        name: string;
    }): void;
    // (undocumented)
    protected _register<ArgumentT extends JsonValue, InputT extends JsonValue, OutputT extends JsonValue>(name: JobName, handler: JobHandler<ArgumentT, InputT, OutputT>, options: RegisterJobOptions): void;
}

// @public (undocumented)
class SimpleMemoryHost implements Host<{}> {
    constructor();
    // (undocumented)
    protected _cache: Map<Path, Stats<SimpleMemoryHostStats>>;
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    protected _delete(path: Path): void;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    protected _exists(path: Path): boolean;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    protected _isDirectory(path: Path): boolean;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    protected _isFile(path: Path): boolean;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    protected _list(path: Path): PathFragment[];
    // (undocumented)
    protected _newDirStats(): {
        inspect(): string;
        isFile(): boolean;
        isDirectory(): boolean;
        size: number;
        atime: Date;
        ctime: Date;
        mtime: Date;
        birthtime: Date;
        content: null;
    };
    // (undocumented)
    protected _newFileStats(content: FileBuffer, oldStats?: Stats<SimpleMemoryHostStats>): {
        inspect(): string;
        isFile(): boolean;
        isDirectory(): boolean;
        size: number;
        atime: Date;
        ctime: Date;
        mtime: Date;
        birthtime: Date;
        content: ArrayBuffer;
    };
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    protected _read(path: Path): FileBuffer;
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    protected _rename(from: Path, to: Path): void;
    // (undocumented)
    reset(): void;
    // (undocumented)
    stat(path: Path): Observable<Stats<{}> | null> | null;
    // (undocumented)
    protected _stat(path: Path): Stats<SimpleMemoryHostStats> | null;
    // (undocumented)
    protected _toAbsolute(path: Path): Path;
    // (undocumented)
    protected _updateWatchers(path: Path, type: HostWatchEventType): void;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    protected _watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent>;
    // (undocumented)
    write(path: Path, content: FileBuffer): Observable<void>;
    protected _write(path: Path, content: FileBuffer): void;
}

// @public (undocumented)
interface SimpleMemoryHostStats {
    // (undocumented)
    readonly content: FileBuffer | null;
}

// @public
class SimpleScheduler<MinimumArgumentT extends JsonValue = JsonValue, MinimumInputT extends JsonValue = JsonValue, MinimumOutputT extends JsonValue = JsonValue> implements Scheduler<MinimumArgumentT, MinimumInputT, MinimumOutputT> {
    constructor(_jobRegistry: Registry<MinimumArgumentT, MinimumInputT, MinimumOutputT>, _schemaRegistry?: schema.SchemaRegistry);
    getDescription(name: JobName): Observable<JobDescription | null>;
    has(name: JobName): Observable<boolean>;
    // (undocumented)
    protected _jobRegistry: Registry<MinimumArgumentT, MinimumInputT, MinimumOutputT>;
    pause(): () => void;
    schedule<A extends MinimumArgumentT, I extends MinimumInputT, O extends MinimumOutputT>(name: JobName, argument: A, options?: ScheduleJobOptions): Job<A, I, O>;
    // (undocumented)
    protected _scheduleJob<A extends MinimumArgumentT, I extends MinimumInputT, O extends MinimumOutputT>(name: JobName, argument: A, options: ScheduleJobOptions, waitable: Observable<never>): Job<A, I, O>;
    // (undocumented)
    protected _schemaRegistry: schema.SchemaRegistry;
}

// @public (undocumented)
interface SmartDefaultProvider<T> {
    // (undocumented)
    (schema: JsonObject): T | Observable<T>;
}

// @public (undocumented)
type Stats<T extends object = {}> = T & {
    isFile(): boolean;
    isDirectory(): boolean;
    readonly size: number;
    readonly atime: Date;
    readonly mtime: Date;
    readonly ctime: Date;
    readonly birthtime: Date;
};

// @public (undocumented)
namespace strategy {
    // (undocumented)
    type JobStrategy<A extends JsonValue = JsonValue, I extends JsonValue = JsonValue, O extends JsonValue = JsonValue> = (handler: JobHandler<A, I, O>, options?: Partial<Readonly<JobDescription>>) => JobHandler<A, I, O>;
    function memoize<A extends JsonValue = JsonValue, I extends JsonValue = JsonValue, O extends JsonValue = JsonValue>(replayMessages?: boolean): JobStrategy<A, I, O>;
    function reuse<A extends JsonValue = JsonValue, I extends JsonValue = JsonValue, O extends JsonValue = JsonValue>(replayMessages?: boolean): JobStrategy<A, I, O>;
    function serialize<A extends JsonValue = JsonValue, I extends JsonValue = JsonValue, O extends JsonValue = JsonValue>(): JobStrategy<A, I, O>;
}

// @public (undocumented)
function stringToFileBuffer(str: string): FileBuffer;

// @public
class SyncDelegateHost<T extends object = {}> {
    constructor(_delegate: Host<T>);
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    get delegate(): Host<T>;
    // (undocumented)
    protected _delegate: Host<T>;
    // (undocumented)
    delete(path: Path): void;
    // (undocumented)
    protected _doSyncCall<ResultT>(observable: Observable<ResultT>): ResultT;
    // (undocumented)
    exists(path: Path): boolean;
    // (undocumented)
    isDirectory(path: Path): boolean;
    // (undocumented)
    isFile(path: Path): boolean;
    // (undocumented)
    list(path: Path): PathFragment[];
    // (undocumented)
    read(path: Path): FileBuffer;
    // (undocumented)
    rename(from: Path, to: Path): void;
    // (undocumented)
    stat(path: Path): Stats<T> | null;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    write(path: Path, content: FileBufferLike): void;
}

// @public (undocumented)
interface SyncHostHandler<StatsT extends object = {}> {
    // (undocumented)
    delete(path: Path): void;
    // (undocumented)
    exists(path: Path): boolean;
    // (undocumented)
    isDirectory(path: Path): boolean;
    // (undocumented)
    isFile(path: Path): boolean;
    // (undocumented)
    list(path: Path): PathFragment[];
    // (undocumented)
    read(path: Path): FileBuffer;
    // (undocumented)
    rename(from: Path, to: Path): void;
    // (undocumented)
    stat(path: Path): Stats<StatsT> | null;
    // (undocumented)
    write(path: Path, content: FileBufferLike): void;
}

// @public (undocumented)
class SynchronousDelegateExpectedException extends BaseException {
    constructor();
}

// @public (undocumented)
namespace test {
    // (undocumented)
    class TestHost extends SimpleMemoryHost {
        // (undocumented)
        $exists(path: string): boolean;
        // (undocumented)
        $isDirectory(path: string): boolean;
        // (undocumented)
        $isFile(path: string): boolean;
        // (undocumented)
        $list(path: string): PathFragment[];
        // (undocumented)
        $read(path: string): string;
        // (undocumented)
        $write(path: string, content: string): void;
        constructor(map?: {
            [path: string]: string;
        });
        // (undocumented)
        clearRecords(): void;
        // (undocumented)
        clone(): TestHost;
        // (undocumented)
        protected _delete(path: Path): void;
        // (undocumented)
        protected _exists(path: Path): boolean;
        // (undocumented)
        get files(): Path[];
        // (undocumented)
        protected _isDirectory(path: Path): boolean;
        // (undocumented)
        protected _isFile(path: Path): boolean;
        // (undocumented)
        protected _list(path: Path): PathFragment[];
        // (undocumented)
        protected _read(path: Path): ArrayBuffer;
        // (undocumented)
        get records(): TestLogRecord[];
        // (undocumented)
        protected _records: TestLogRecord[];
        // (undocumented)
        protected _rename(from: Path, to: Path): void;
        // (undocumented)
        protected _stat(path: Path): Stats<SimpleMemoryHostStats> | null;
        // (undocumented)
        get sync(): SyncDelegateHost<{}>;
        // (undocumented)
        protected _sync: SyncDelegateHost<{}> | null;
        // (undocumented)
        protected _watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent>;
        // (undocumented)
        protected _write(path: Path, content: FileBuffer): void;
    }
    // (undocumented)
    type TestLogRecord = {
        kind: 'write' | 'read' | 'delete' | 'list' | 'exists' | 'isDirectory' | 'isFile' | 'stat' | 'watch';
        path: Path;
    } | {
        kind: 'rename';
        from: Path;
        to: Path;
    };
}

// @public (undocumented)
class TransformLogger extends Logger {
    constructor(name: string, transform: (stream: Observable<LogEntry>) => Observable<LogEntry>, parent?: Logger | null);
}

declare namespace transforms {
    export {
        addUndefinedDefaults
    }
}

// @public (undocumented)
type UriHandler = (uri: string) => Observable<JsonObject> | Promise<JsonObject> | null | undefined;

// @public
function visitJson<ContextT>(json: JsonValue, visitor: JsonVisitor, schema?: JsonSchema, refResolver?: ReferenceResolver<ContextT>, context?: ContextT): Observable<JsonValue>;

// @public (undocumented)
function visitJsonSchema(schema: JsonSchema, visitor: JsonSchemaVisitor): void;

// (No @packageDocumentation comment for this package)

```
